virtual的作用就是告诉编译器：我要进行动态绑定！编译器当然会尊重你的意见，而且为了完成你这个要求，编译器还要做很多的事情：编译器自动在声明
了virtual方法的类中插入一个指针vptr和一个数据结构VTable（vptr用以指向VTable；VTable是一个指针数组，里面存放着函数的地址），并保证二者遵守
下面的规则：

1、VTable中只能存放声明为virtual的方法，其它方法不能存放在里面。在上面的例子中，Shape的VTable中就只有Draw，MoveTo和~Shape。方法Erase的地址
并不能存放在VTable中。此外，如果方法是纯虚函数，如 Draw，那么同样要在VTable中保留相应的位置，但是由于纯虚函数没有函数体，因此该位置中并不
存放Draw的地址，而是可以选择存放一个出错处理的函数的地址，当该位置被意外调用时，可以用出错函数进行相应的处理。
2、派生类的VTalbe中记录的从基类中继承下来的虚函数地址的索引号必须跟该虚函数在基类VTable中的索引号保持一致。如在上例中，如果在Shape的VTalbe
中，Draw为 1 号， MoveTo 2 号，~Shape为 3 号，那么，不管这些方法在Circle中是按照什么顺序定义的，Circle的VTable中都必须保证Draw为 1 号，
MoveTo为 2号。至于 3号，这里是~Circle。为什么不是~Shape啊？嘿嘿，忘啦，析构函数不会继承的。
3、vptr是由编译器自动插入生成的，因此编译器必须负责为其进行初始化。初始化的时间选在对象创建时，而地点就在构造函数中。因此，编译器必须保证
每个类至少有一个构造函数，若没有，自动为其生成一个默认构造函数。
4、vptr通常放在对象的起始处，也就是Addr(obj) == Addr(obj.vptr)。

Shape *pShape = new Circle(50, 100, 25);
pShape->Draw();   // Draw为虚函数

前面已经提到，晚期绑定时之所以不能确定调用哪个函数，是因为具体的对象不确定。好了，当运行到pShape->Draw()时，对象出来了，它由pShape指针标出。
我们找到这个对象后，就可以找到它里面的vptr（在对象的起始处），有了vptr后，我们就找到了VTable，调用的函数就在眼前了。。等等，VTable中方法
那么多，我究竟使用哪个呢？不用着急，编译器早已为我们做好了记录：编译器在创建VTable时，已经为每个virtual函数安排好了座次，并且把这个索引号
记录了下来。因此，当编译器解析到pShape->Draw()的时候，它已经悄悄的将函数的名字用索引号来代替了。这时候，我们通过这个索引号就可以在VTable中
得到一个函数地址，Call it！
