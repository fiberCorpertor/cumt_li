C++ STL 的实现：

1.vector      底层数据结构为数组 ，支持快速随机访问

2.list        底层数据结构为双向链表，支持快速增删

3.deque       底层数据结构为一个中央控制器和多个缓冲区，详细见STL源码剖析P146，支持首尾（中间不能）快速增删，也支持随机访问

  deque是一个双端队列(double-ended queue)，也是在堆中保存内容的.它的保存形式如下:
  [堆1] --> [堆2] -->[堆3] --> ...
  每个堆保存好几个元素,然后堆和堆之间有指针指向,看起来像是list和vector的结合品.


4.stack     底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时

5.queue     底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时

（stack和queue其实是适配器,而不叫容器，因为是对容器的再封装）

6.priority_queue  的底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现

7.set           底层数据结构为红黑树，有序，不重复

8.multiset      底层数据结构为红黑树，有序，可重复

9.map           底层数据结构为红黑树，有序，不重复

10.multimap     底层数据结构为红黑树，有序，可重复

11.hash_set     底层数据结构为hash表，无序，不重复

12.hash_multiset 底层数据结构为hash表，无序，可重复

13.hash_map     底层数据结构为hash表，无序，不重复

14.hash_multimap 底层数据结构为hash表，无序，可重复 

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
1、STL的map底层是用红黑树实现的，查找时间复杂度是log(n)；
2、STL的hash_map底层是用hash表存储的，查询时间复杂度是O(1)；哈希表最大的优点是：把数据存储和查询消耗的时间大大降低，几乎可以看成是常数时间；
而代价仅仅是消耗比较多的内存。

总 体来说，hash_map 查找速度会比map快，而且查找速度基本和数据数据量大小，属于常数级别;而map的查找速度是log(n)级别。并不一定常数就比log(n)
小， hash还有hash函数的耗时，明白了吧，如果你考虑效率，特别是在元素达到一定数量级时，考虑考虑hash_map。但若你对内存使用特别严格，希望 
程序尽可能少消耗内存，那么一定要小心，hash_map可能会让你陷入尴尬，特别是当你的hash_map对象特别多时，你就更无法控制了，而且 hash_map的构造
速度较慢。
现在知道如何选择了吗？权衡三个因素: 查找速度, 数据量, 内存使用。
