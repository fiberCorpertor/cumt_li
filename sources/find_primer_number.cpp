// 思路参考：
// 由于一个合数总是可以分解成若干个质数的乘积，那么如果把质数（最初只知道2是质数）的倍数都去掉，那么剩下的就是质数了
// 例如要查找100以内的质数，首先2是质数，把2的倍数去掉；此时3没有被去掉，可认为是质数，所以把3的倍数去掉；再到5，再到7，7之后呢，
// 因为8，9，10刚才都被去掉了，而100以内的任意合数肯定都有一个因子小于10（100的开方），所以，去掉，2，3，5，7的倍数后剩下的都是质数了
void FindPrimeNumber(int n)
{
    bool* a = new bool[n + 1];
    for (int i = 2; i <= n; i++)
      a[i] = true;

    for (int i = 2; i <= sqrt(n); i++)
    {
      if (a[i])
      {
        // 比如i=2，则 2 * 2, 2 * 3, 2* 4等等都不会是质数了，因为至少有2这个因子了，以此类推3 * 3, 3 * 4.....也都不是，筛选法就是这个道理
        for (int j = i; j*i <= n; j++)
          a[j * i] = false;
      }
    }
    //for (int i = 0; i <= n; i++)
    //{
    //  if (a[i])
    //    cout<<i<<"\t";
    //}
}
